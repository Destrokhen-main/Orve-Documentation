import subTitle from "../../helper/subTitle";
import Code from "../../helper/Code";

import Layer from "../../helper/LayerBody"

export default function() {
  return {
    tag: Layer,
    child: [
      {
        tag: subTitle,
        child: "Reactive Object"
      },
      `<p>
        Данная статья, была специально расположена после асинхронных функций, сейчас покажу почему.<br/>
        В прошлой статье, мы столкнулись с тем, что объявляли единичные ref для объекта.<br />
        Отсюда появляется вопрос, а что делать, если в объекте, могут добавляться по ходу новые свойства.
        <br/>
        <br/>
        Конечно мы можем делать так.
      </p>`,
      {
        tag: Code,
        child: `
        const obj = {
          ....
        }
        obj["key"] = ref("ss")
        `
      },
      `<p>
        Но тогда, появится боль, при использование effect. Ведь мы хотим один раз указать зависимость, а не заполнять её каждый раз.<br/>
        Тут на помощью приходит refO.
      </p>`,
      {
        tag: Code,
        child: `
        import { refO } from "orve"

        const object = refO({
          ....
        });
        `
      },
      `<p>
        Чем же он хорош?<br/>
        Ну у вас есть возможность более проще добавлять свойства.
      </p>`,
      {
        tag: Code,
        child: `
        const s = refO({
          ....
        });

        s.key = value;
        `
      },
      `<p>
        Теперь это свойство станет реактивным)<br/>
        <br />
        Вы так же можете прописать в него сужествующие прокси. Наверно у вас появится такая потребность)<br/>
        А так же, вы можете, использовать весь объект или частями для прописывания в effect
      </p>`,
      {
        tag: Code,
        child: `
        const obj = refO({
          t: ""
        })

        return {
          tag: "div",
          child: effect(() => {}, [obj.t])
        }

        /* или */
        
        return {
          tag: "div",
          child: effect(() => {}, [obj])
        }
        `
      },
      `<p>
        Первая запись даст вам возможность следить за всеми изменениями в пределах одной переменной. Вторая позволит следить за всеми изменениями в объекте.<br/>
        <br />
        Стоит заметить, что указывать весь refO не стоит в компоненте, это ничего вам не даст), а может даже спровоцирует ошибку.
        <br/><br/>
        Как менять часть объекта
      </p>`,
      {
        tag: Code,
        child: `
        const s = refO({
          x: ""
        });

        s.x.value = ""
        `
      },
      `<p>
        На самом деле, все так же как и в обычном ref.
        <br/><br/>
        А так же как указывать в компоненте
      </p>`,
      {
        tag: Code,
        child: `
        const s = refO({
          k: "Hi"
        });

        return {
          tag: "div",
          child: s.k
        }
        `
      }
    ]
  }
}